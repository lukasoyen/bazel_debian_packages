"repository rule for generating a dependency graph from a lockfile."

load("//apt/private:util.bzl", "util")

_ROOT_BUILD_TMPL = """\
"Generated by rules_linux_toolchains. DO NOT EDIT."

alias(
    name = "lock",
    actual = "@{target_name}//:lock",
    visibility = ["//visibility:public"],
)
"""

def _extract_data_file(rctx, host_tar, path):
    cmd = [host_tar, "-xf", path]
    result = rctx.execute(cmd)
    if result.return_code:
        fail("Failed to extract data file: {} ({}, {}, {})".format(
            " ".join(cmd),
            result.return_code,
            result.stdout,
            result.stderr,
        ))

def _create_sysroot_impl(rctx):
    host_tar = util.get_host_tool(rctx, "bsd_tar", "tar")

    index = json.decode(rctx.read(util.get_repo_path(rctx, rctx.attr.source, "index.json")))

    # otherwise assume we are in the initial lockfile generation
    if index:
        if rctx.attr.architecture not in index:
            fail(
                "Misconfigured `sysroot()`. Can not find the provided architecture {} in packages from {}".format(rctx.attr.architecture, rctx.attr.source),
            )

        for package in index[rctx.attr.architecture]:
            path = rctx.path(Label(package))
            _extract_data_file(rctx, host_tar, path)

    rctx.file("BUILD.bazel", _ROOT_BUILD_TMPL.format(
        target_name = rctx.attr.source,
    ))

create_sysroot = repository_rule(
    implementation = _create_sysroot_impl,
    attrs = {
        "install_name": attr.string(mandatory = True),
        "architecture": attr.string(mandatory = True),
        "source": attr.string(mandatory = True),
    },
)
