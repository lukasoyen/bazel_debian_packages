"repository rule for generating a dependency graph from a lockfile."

load("@aspect_bazel_lib//lib:repo_utils.bzl", "repo_utils")
load("@bazel_skylib//lib:paths.bzl", "paths")
load(":lockfile.bzl", "lockfile")
load(":util.bzl", "util")

_ROOT_BUILD_TMPL = """\
"Generated by rules_linux_toolchains. DO NOT EDIT."

alias(
    name = "lock",
    actual = "@{target_name}_resolve//:lock",
    visibility = ["//visibility:public"],
)
"""

def _get_host_tool(rctx, repo, name):
    is_windows = repo_utils.is_windows(rctx)
    return str(rctx.path(Label("@{}_{}//:{}{}".format(
        repo,
        repo_utils.platform(rctx),
        ".exe" if is_windows else "",
        name,
    ))))

def _find_data_file(rctx, package_key):
    # Debian data.tar files can be:
    #  - .tar uncompressed, supported since dpkg 1.10.24
    #  - .tar compressed with
    #    *  gzip: .gz
    #    * bzip2: .bz2, supported since dpkg 1.10.24
    #    *  lzma: .lzma, supported since dpkg 1.13.25
    #    *    xz: .xz, supported since dpkg 1.15.6
    #    *  zstd: .zst, supported since dpkg 1.21.18
    for ext in (".zst", ".xz", ".lzma", ".bz2", ".gz", ""):
        path = rctx.path("_packages/{}/data.tar{}".format(package_key, ext))
        if path.exists:
            return str(path)
    fail("{}: unable to find data file for {}".format(rctx.name, package_key))

def _decompress_data_file(rctx, host_zstd, path):
    (output, ext) = paths.split_extension(path)
    if ext == ".bzip2":
        fail("{}: unsupported bzip2 compression for {}".format(rctx.name, path))

    cmd = [host_zstd, "--decompress", "--force", "-o", output, path]
    result = rctx.execute(cmd)
    if result.return_code:
        fail("Failed to decompress data file: {} ({}, {}, {})".format(
            " ".join(cmd),
            result.return_code,
            result.stdout,
            result.stderr,
        ))
    return path

def _extract_data_file(rctx, host_tar, path):
    cmd = [host_tar, "-xf", path]
    result = rctx.execute(cmd)
    if result.return_code:
        fail("Failed to extract data file: {} ({}, {}, {})".format(
            " ".join(cmd),
            result.return_code,
            result.stdout,
            result.stderr,
        ))

def _deb_create_sysroot_impl(rctx):
    lock_content = rctx.attr.lock_content
    lockf = lockfile.from_json(
        rctx,
        lock_content if lock_content else rctx.read(rctx.attr.lock),
    )

    host_tar = _get_host_tool(rctx, "bsd_tar", "tar")
    host_zstd = _get_host_tool(rctx, "zstd", "zstd")

    for (package) in lockf.packages():
        if rctx.attr.arch == package["arch"]:
            package_key = lockfile.make_package_key(
                package["name"],
                package["version"],
                package["arch"],
            )
            rctx.download_and_extract(
                package["url"],
                sha256 = package["sha256"],
                output = "_packages/" + package_key,
            )

            path = _find_data_file(rctx, package_key)
            if not path.endswith(".tar"):
                path = _decompress_data_file(rctx, host_zstd, path)
            _extract_data_file(rctx, host_tar, path)

    rctx.file("BUILD.bazel", _ROOT_BUILD_TMPL.format(
        target_name = util.get_repo_name(rctx.attr.name),
    ))

deb_create_sysroot = repository_rule(
    implementation = _deb_create_sysroot_impl,
    attrs = {
        "arch": attr.string(),
        "lock": attr.label(),
        "lock_content": attr.string(doc = "INTERNAL: DO NOT USE"),
    },
)
